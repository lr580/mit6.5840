[mit6.5840网址](http://nil.csail.mit.edu/6.5840/2025/)

# 实现过程

## Lab1

### 环境准备

根据 [lab1](http://nil.csail.mit.edu/6.5840/2025/labs/lab-mr.html) 的第一句话，克隆远程仓库获取源码

```sh
git clone git://g.csail.mit.edu/6.5840-golabs-2025 6.5840
```

在 [setup go](http://nil.csail.mit.edu/6.5840/2025/labs/go.html)，需求 Go 1.22 版本，使用 `go version` 可查询版本。

需求使用 Linux，这里我使用 WSL2。按照指示检查运行：

> ```go
> cd src/main
> go build -buildmode=plugin ../mrapps/wc.go
> rm mr-out*
> go run mrsequential.go wc.so pg*.txt
> more mr-out-0
> ```

其中，build的构建模式为plugin，它生成`.so` 文件，即 `wc.go`，项目结构 `src/`

- `mrapps/` 是 map-reduce 实际应用例子，如 `wc.go`，看到它定义了 Map 和 Reduce 函数。其中 Map 函数的第一个参数在例子中忽略，只看第二个参数(文件内容)，它把不是 Letter(a-zA-Z) 的连续内容作为分隔符，然后分割后的单词数组返回 (`mr/KeyValue`) (没有做合并)。Reduce 函数，传入 key 值和 values 列表，values 长度转字符串作为该 key 的合并结果。
- 对 `main/mrsequential.go`，传入 `.so` 执行，选择文件名执行。它的 `loadPlugin` 函数，导入插件，查找 Map, Reduce 函数，并返回。对每一份文件，把读取的文件内容和文件名传入 map 函数，得到 key-value 列表；所有文件的合并到一个列表里。(实际上应该分快存储)，然后进行排序，创建输出文件。排序后 key 相同的全部 value 集合并到一个 string[] 里。把这个 slice 传给 reduce 函数，然后输出结果到文件。

### 任务描述

#### 任务

实现：协调节点coordinator, 工作节点worker。单协调进程，任意多个工作节点，该lab只考虑工作节点都在同一个机子。使用RPC，循环请求协调者执行任务。协调者应当注意若工作者在10秒内未能完成任务，将它分发给其他工作者。

`main/mrcoorinator.go`, `main/mrworker.go` 是给定不可修改的代码，参考它们，实现 `mr/coordinator.go`，`mr/worker.go`，`mr/rpc.go`。执行 mapreduce 的过程：

```sh
go run mrcoordinator.go pg-*.txt # 一个
go run mrworker.go wc.so # 一个或多个
cat mr-out-* | sort | more # 查看结果
```

使用测试脚本检查 `wc, indexer` 任务是否产出正确，以及测试是否并行，能否恢复crash。

```sh
bash test-mr.sh
```

把 `mr/coordinator.go` 的 Done 函数改为`ret := true`，让协调者马上退出。如果全部通过，测试完成。

若 rpc 报错如 ` method "Done" has 1 input parameters`，可以忽略，因为它不会被远程调用。[文档](https://golang.org/src/net/rpc/server.go) 帮助检查是否所有方法对 RPC 合适，即有 3 输入。若出现 `connect: connection refused`，当协调者关闭后，无法连接是正常的。

#### 规则

- map 阶段，分割中间 keys 为桶，给 `nReduce` 个任务，在 `main/mrcoordinator.go` 该参数传递给 `MakeCoordinator()`，每个 mapper 要创建 `nReduce` 个中间文件给 reduce 任务消费。
- 工作者实现第 X 个 reduce 任务时，写到 `mr-out-X`。该文件对每个 Reduce 函数输出包含一行，使用 format `%v %v` 生成 key value 行。查阅 `main/sequential.go` 查看格式范例。
- 工作者把中间 Map 输出放当前工作目录。
- `main/mrcoordinator.go` 期望 `mr/coordinator.go` 实现 `Done()` 方法，返回 true 如果任务执行完毕，随后 `mrcoordinator.go` 退出。
- 全部任务完成，工作者进程关闭，可以用 `call()` 的返回值实现。若工作者无法联系协调者，可以假设任务完毕，并让工作者关闭。也可以自由发挥。

#### 提示

- 一个开始的办法是调整 `mr/worker.go` 的 `Worker()` 发送 RPC 给协调者请求任务，然后修改协调者回答未开始的map任务文件名，然后修改工作者去读取文件，调用 Map 函数。
- 使用 go plugin 加载 map, reduce 任务，`.so` 文件。如果修改 `mr/` 的内容，可能需要重新构造 `.so`。
- 工作者共享同一个文件系统。
- 中间文件可以命名为 `mr-X-Y`，分别表示 map, reduce 编号。
- map 任务需要存储中间键值对在文件，使其可以在 reduce 被读取，可以考虑 json 包，参考示例代码读写。
- 可以使用 `ihash(key)` 函数(`worker.go`)选择reduce任务。
- 读文件，排序，存储reduce输出，可以参考 `mrsequential.go`。
- 协调者并发，需要锁住共享数据。
- 使用 Go race detector，如 `go run -race`。在 `test-mr.sh` 开头有注释，提示如何使用。
- 工作者有时需要等待，如 reduce 需要等最后一个 map 完成。可以周期轮询+sleep；或者 RPC 做一个等待循环，sync.Cond。每个 RPC handler 独立线程，所以 handler 等待不会阻止协调者处理其他 RPC。
- 协调者无法区分崩掉的、静止的、太慢的工作者。只能让协调者等待一段时间，然后切换工作者。
- 若实现文章 Section 3.6 的 Backup 任务，它只应当长时间后才被安排，如10s，也就是有挂掉的。
- 测试 crash，可以尝试 `mrapps/crash.go`，它随机关闭 map/reduce 函数。
- 防止 crash 导致写了一半的文件，MapReduce 论文使用 trick：使用临时文件，并原子地重命名它，如果完成了写。使用 `ioutil.TempFile / os.CreateTemp` 来创建这样的文件，然后 `os.Rename` 原子重命名。
- `test-mr.sh` 运行所有进程在 `mr-tmp`，如果挂了，中间过程在该文件找。
- `test-mr-many.sh` 运行多次，可以发现低概率错误。参数：运行次数。不要通过自己跑多次 `test-nr.sh` 来做它，这样协调者会复用一个 socket。
- Go RPC 只发送大写结构体字段，子结构体也是如此。
- 调用 RPC `call()`，返回结构体要所有字段赋值为默认值，有参见例子。否则，可能结果不对。

#### 通用提示

[url](http://nil.csail.mit.edu/6.5840/2025/labs/guidance.html)：

- Easy：数小时；Moderate：6h每周；hard：超过6h每周。

  大部分任务只需要几百行代码，但概念+debug困难。

- 在线 Go 教程 [here](http://tour.golang.org/)，[Effective Go](https://golang.org/doc/effective_go.html)，[Editor](https://golang.org/doc/editors.html)

- [race detector](https://blog.golang.org/race-detector) 报告的 race 需要修复。

- [Raft](https://thesquareplanet.com/blog/students-guide-to-raft/) 指引

- [locking](http://nil.csail.mit.edu/6.5840/2025/labs/raft-locking.txt) 指引

- [Raft structuring](http://nil.csail.mit.edu/6.5840/2025/labs/raft-structure.txt) 指引

- [图解Raft交互](http://nil.csail.mit.edu/6.5840/2025/notes/raft_diagram.pdf)

- 在每个节点收发消息关键位置 print，日志重定向到文件来分析，方便 debug

  结构化 debug 输出信息，那么 grep 查找消息更方便

- `DPrintf` 比 `log.Printf` 更有用

- [Go format strings](https://golang.org/pkg/fmt/)

- 颜色 / 列来解析 log 输出 [参考](https://blog.josejg.com/debugging-pretty/)

- git 教程 [url](https://git-scm.com/book/en/v2) [url2](https://www.kernel.org/pub/software/scm/git/docs/user-manual.html)

#### 调试技巧

先对问题的潜在成因提出假设；收集可能相关的证据；综合分析已获取的信息；根据需要重复上述过程。对于长时间的调试任务，建议做好记录

一种有效策略是逐步定位问题首次出现的时间节点。可以在程序执行的不同阶段插入状态检查代码，或是添加输出关键状态信息的日志语句，将日志保存至文件后仔细排查首个出现异常的时间点

Raft实验涉及的事件（如RPC请求到达、超时触发、节点故障）可能在意料之外的时刻发生，或以难以预料的顺序交错出现。例如某个节点刚决定参与竞选，而另一个节点却认为自己是当前领导者。建议推演"后续可能发生的情况"：比如当Raft代码释放互斥锁后，下一瞬间可能就会处理到达的RPC请求或超时事件。可通过打印语句来捕获实际的事件执行顺序。

必须严格遵循Raft论文图2的规范，容易遗漏其中规定的状态检查条件或必须执行的状态变更。若出现故障，请重新核验代码是否完全符合图2要求。

在编写代码时（即出现故障前），建议对代码依赖的前提条件添加显式检查（例如使用Go的[panic](https://gobyexample.com/panic)机制）。这类检查有助于发现后续代码无意中违背假设的情况。

若原本正常的代码出现异常，很可能是近期修改引入的问题。

故障往往藏在你最后检查的地方，因此即使对确信无误的代码也需保持审视

#### 挑战任务

- 实现自己的 MapReduce 任务，可以看 `mrapps/*` 例子，如文章 Section 2.3 的分布式 Grep。
- 让协调者，工作者在不同机器上工作，设置 RPC 在 TCP/IP 而不是 Unix sockets (参考注释 `Coordinator.server()`)，用共享文件系统读写文件。如 `ssh` 多个 [Athena cluster](http://kb.mit.edu/confluence/display/istcontrib/Getting+Started+with+Athena)，使用 [AFS](http://kb.mit.edu/confluence/display/istcontrib/AFS+at+MIT+-+An+Introduction) 共享文件，或自己用 AWS 实例 / S3 存储。

#### 代码梳理

`main/mrcoordinator.go` main 函数，把命令行参数全部传进去，以及 nReduce=10，执行 `mr.MakeCoordinator`，完毕 sleep 1s，返回值为 m，若 `m.Done()` 是 false，就多 sleep 1s。

`main/mrworker.go` main 函数，对 CLI 参数加载 plugin，调用 `mr.Worker` 执行 map, reduce。

`mr/rpc.go` 给定例子使用 RPC，对该例子，`mr/coordinator.go` 定义了 Example 函数，`mr/worker.go` 定义了 `CallExample()` 函数。在 `mr/worker.go` 定义了 call 函数，在 `mr/coordinator.go` 定义了 `server()` 结构体方法，用来执行 RPC。

`mr/worker.go` 定义了 ihash 函数用于字符串转 int。定义了 `KeyValue` 结构体。定义了 `Worker` 函数需要自己实现。

`mr/coordinator.go` 定义了 `Coordinator` 结构体及其成员方法(需要自己补充成员属性)。需要实现：①MakeCoordinator构造函数；②Done成员函数。



# 过程记录

- 2025/9/29 2h 阅读Lab1代码，学习go语法
- 2025/10/1 2h 阅读Lab1代码、要求与指示，学习go RPC等